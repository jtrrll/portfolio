// A collection of templ components.
package components

import "strings"

// A site-wide layout.
templ Layout(title string, description string) {
	<!DOCTYPE html>
	<html lang="en">
		@head(title, description)
		<body>
			@navbar(
				navLink{text: "home", href: templ.URL("/")},
				navLink{text: "software", href: templ.URL("/software")},
				navLink{text: "interactive", href: templ.URL("/interactive")},
				navLink{text: "visual", href: templ.URL("/visual")},
				navLink{text: "audio", href: templ.URL("/audio")},
			)
			<main>
				{ children... }
			</main>
			@preloadManager()
		</body>
	</html>
}

// A site-wide HTML head component.
templ head(title string, description string) {
	<head>
		<meta charset="utf-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<title>{ title }</title>
		<link rel="icon" href="/static/favicon.ico"/>
		<link rel="stylesheet" href="/static/preflight.css"/>
		<link rel="stylesheet" href="/static/styles.css"/>
		<link rel="preconnect" href="https://fonts.googleapis.com"/>
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
		<link href="https://fonts.googleapis.com/css2?family=Anybody:ital,wdth,wght@0,50..150,100..900;1,50..150,100..900&family=IBM+Plex+Sans:ital,wdth,wght@0,75..100,100..700;1,75..100,100..700&display=swap" rel="stylesheet"/>
		<meta name="description" content={ description }/>
	</head>
}

type navLink struct {
	text string
	href templ.SafeURL
}

// A site-wide navigation bar.
templ navbar(links ...navLink) {
	<div class="navbar">
		<nav>
			<a href="/" preload class="clickable logo">
				jtrrll
			</a>
			<ul>
				for _, link := range links {
					<li>
						<a href={ link.href } preload class="clickable">
							{ strings.ToLower(link.text) }
						</a>
					</li>
				}
			</ul>
		</nav>
		<div
			style="
			background-color: color-mix(in srgb, var(--color-dark) 25%, transparent);
    	height: 0.125rem;
		"
		>
			<div
				loading-bar
				style="
				background-color: var(--color-dark);
				height: 100%;
				transition: width 500ms ease-out;
				width: 0%;
			"
			></div>
		</div>
		@loadingBarManager()
	</div>
}

var loadingBarHandle = templ.NewOnceHandle()

// Manages progress animations for loading bars.
templ loadingBarManager() {
	@loadingBarHandle.Once() {
		<script>
			window.addEventListener('load', () => {
				document.querySelectorAll('[loading-bar]').forEach((loadingBar) => {
					requestAnimationFrame(() => {
						loadingBar.style.width = "100%";
					});
				});
			});
		</script>
	}
}

var preloadHandle = templ.NewOnceHandle()

// Manages preloading for anchor tags with the "preload" attribute.
templ preloadManager() {
	@preloadHandle.Once() {
		<script>
			const preloadedUrls = new Set();
			const preloadDelay = 20; // ms delay before preloading starts

			function setupPreload(link) {
				let preloadTimer = null;

				const doPreload = (href) => {
					if (!href || preloadedUrls.has(href)) return;

					// Use fetch to preload and populate the browser's HTTP cache
					fetch(href, {
						method: 'GET',
						credentials: 'same-origin',
						priority: 'low'
					}).then(() => {
						preloadedUrls.add(href);
					}, () => {});
				};

				link.addEventListener('mouseenter', () => {
					const href = link.getAttribute('href');
					if (!href || preloadedUrls.has(href)) return;

					// Short delay to avoid preloading on accidental hovers
					preloadTimer = setTimeout(() => doPreload(href), preloadDelay);
				});

				link.addEventListener('mouseleave', () => {
					// Clear timer if user moves away quickly
					if (preloadTimer) {
						clearTimeout(preloadTimer);
						preloadTimer = null;
					}
				});

				// Also preload on touchstart for mobile devices
				link.addEventListener('touchstart', () => {
					const href = link.getAttribute('href');
					doPreload(href);
				}, { passive: true });
			}

			// Setup existing links with preload attribute
			document.querySelectorAll('a[preload]').forEach(setupPreload);

			// Watch for new links added dynamically
			const observer = new MutationObserver((mutations) => {
				mutations.forEach((mutation) => {
					mutation.addedNodes.forEach((node) => {
						if (node.nodeType === 1) { // Element node
							if (node.matches && node.matches('a[preload]')) {
								setupPreload(node);
							}
							if (node.querySelectorAll) {
								node.querySelectorAll('a[preload]').forEach(setupPreload);
							}
						}
					});
				});
			});

			observer.observe(document.body, { childList: true, subtree: true });
		</script>
	}
}
